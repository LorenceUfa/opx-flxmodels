package models

import("encoding/json"
		  "fmt"
      )

type ConfigObj interface {
	     UnmarshalObject(data []byte) (ConfigObj, error)
}

//
// This file is handcoded for now. Eventually this would be generated by yang compiler
//
type IPV4Route struct {
	DestinationNw string
	NetworkMask string
	Cost int
	NextHopIp string
	OutgoingInterface  string
	Protocol string
}

func (obj IPV4Route) UnmarshalObject(body []byte) (ConfigObj, error) {
	var v4Route IPV4Route
	 var err  error
	if err = json.Unmarshal(body, &v4Route); err != nil  {
		fmt.Println("### IPV4Route Create is called", v4Route)
	}
	 fmt.Println("### IPV4Route Create is Unmarshal Object", err, v4Route)
	 return v4Route, err 
}

type Vlan struct {
	VlanId  int
	PortMap  string
}

func (obj Vlan) UnmarshalObject(data []byte) (ConfigObj, error) {
	 return Vlan{}, nil
}

type GlobalConfig struct {
	AS uint32
	RouterId string
}

type GlobalState struct {
	AS uint32
	RouterId string
	TotalPaths uint32
	TotalPrefixes uint32
}

type PeerType int

const (
	PeerTypeInternal PeerType = iota
	PeerTypeExternal
)

type BgpCounters struct {
	Update uint64
	Notification uint64
}

type Messages struct {
	Sent BgpCounters
	Received BgpCounters
}

type Queues struct {
	Input uint32
	Output uint32
}

type NeighborConfig struct {
	PeerAS uint32
	LocalAS uint32
	AuthPassword string
	Description string
	NeighborAddress string
}

type NeighborState struct {
	PeerAS uint32
	LocalAS uint32
	PeerType PeerType
	AuthPassword string
	Description string
	NeighborAddress string
	SessionState uint32
	Messages Messages
	Queues Queues
}
